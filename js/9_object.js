/**
 *  객체, `키:값`을 여러 개 가진 `컬렉션 타입`
 *      - 데이터간 서열 x
 *      - 클래스 형태를 표방, 객체지향을 모방하기 때문에 객체지향 스타일을 지향
 *          - 상속, 재정의, 생성자, 멤버 라는 개념이 모두 포함
 *      - {}로 표현
 *      - JS의 객체 생성 방식 -> 5가지
 *          - (*)1. 객체 리터럴
 *          - 2. object 확장
 *          - 3. 생성자 함수
 *              - 메모리적인 낭비가 존재할 수 있다
 *          - (*)4. 생성자 함수 + 프로토타입 확장 방식 => 객체를 표현하는 가장 본질적인 방식
 *          - (*)5. class 구현
 *              - es Next에서 추가됨
 *              - 초창기 5년간 react 개발 시 주력으로 사용됨 => 현재는 잘 사용 x
 *                  - react에서 훅이 추가되면서 함수형에서도  class형의 기능들을 대체할 수 있게됨
 *              - 4번 방식에 일반적인 클래스 형식을 도입
 *      - 객체
 *          - 이 세상에 존재하는 모든 유형|무형의 존재를 엔티티라고 함
 *              - 유형 : 자동차, 사람, 컴퓨터, ..
 *              - 무형 : 개념, 민주주의, ..
 *          - 엔티티를 프로그램 세상에서 표현하기 위해서 제공하는 문법적 방식 -> class
 *              - class 문법을 이용하여 엔티티를 코드로 표현한 것
 *              - JS에서는 1~5번까지 문법 사항
 *          - class로 작성한 내용을 메모리에 띄움(실행하기 위함) -> 객체
 *              - 여러번 생성 가능
 *              - 객체는 메모리상에 주소를 가진다
 *              - 특정 변수가 이 메모리상에 객체를 참조하면 이 변수는 
 *                객체를 참조하는 변수라고 부른다 (참조형 변수)
 *              - let a = 10
 *                a = "hi"
 *                a는 가르키는 대상이 바뀌었을 뿐 => a의 타입은 가르키는 대상에 따라 결정 (=타입 추론형)
 */

// 1. 객체 리터럴 => { ... }
// 용도 -> 1회성으로 `여러개의 데이터를 묶어서 전달(함수의 인자로)`할 때
const obj = {}; // object 타입
console.log(obj, typeof obj);

let height = 170; // 전역변수
let w = "weight"; // 동적속성명 지원을 위한 샘플, 이 값을 키로 사용하고 싶다
const obj1 = {
    // 데이터 추가(데이터 관점), 멤버를 추가(객체지향 프로그래밍 관점)
    // 키 : 값(모든 타입(단일형, 연속형, 컬렉션, 함수, ...) 가능)
    name : "JS",
    age : 33,
    height, // 전역변수를 추가함으로서 데이터 혹은 멤버로 추가
    // 동적 속성명 추가
    [w] : 60, // computed property names 동적 속성 이름 정의
    arr : [1, 2, 3, 4],
    spec : {},
    // 함수
    getAge : function () {
        // (*)객체 내부에서 멤버에 접근하는 내용이 존재하면 표준(익명) 함수 형태
        // 같은 구성원의 데이터를 사용하고 싶다
        // 객체 내의 멤버를 접근하고 싶다
        // 객체를 지칭하는 용어는? => this (타언어에는 self도 가능)
        return `${this.name}의 나이는 ${this.age} 입니다.`;
        // 화살표 함수 내부에서 this 사용 주의 필요(가급적 배제)
    },
    print(){
        console.log("출력");
    }
};
console.log(obj1)
// 객체의 멤버(데이터, 함수)를 접근할 때 사용하는 연산자 => . (도트 연산자)
// 객체명.변수, 객체명.함수, 객체명['키 값']
console.log(obj1.age, obj1['age']);
console.log(obj1.getAge());

// 4. 생성자 함수 + 프로토타입(확장시)
// 생성자함수 => 첫글자 대문자(통상 클래스명)
function Person (nm) {
    // 생성자 => 객체지향프러그램, 클래스에서는 객체를 생성할 때 호출되는 함수
    // 생성자 호출 => 객체가 생성되었구나라고 인지
    // 생성자 주 업무 : 객체 생성, 멤버 초기화
    // 특이점, this가 잘 보인다
    // this.nm : 멤버변수, 데이터
    this.nm = nm;
}
// 객체 생성
// 함수 호출 시 new가 들어가면 생성자 함수로 인지
// new는 객체를 생성하는 키워드
// const 객체명 = new 생성자함수(인자);
const person = new Person('JS');
console.log(person); // Person { nm: 'JS' } <= Person 객체로 표현

// 프로토타입 확장 -> 객체 생성 시 포함되지 않는다. 공용으로 객체 간에 사용됨
// 객체에 변수, 함수 형태를 확장하는 방식
// 생성자함수명.prototype.확장할요소명 = 변수|함수|...
Person.prototype.nm2 = '별명';
Person.prototype.getNm2 = function () {
    console.log(`${this.nm} ${this.nm2}`);
};
console.log(Person) // [Function: Person]
console.log(person) // Person {nm: 'JS'}, 객체 자체는 변동이 없어보임
// 확장된 요소 접근
console.log( 'person.nm2 => ', person.nm2);
person.getNm2();

// 결론
// prototype으로 함수를 확장하여 추가함
// 수십개의 객체가 동일하게 만들어져도, 함수는 오직 1개만 서로 공유하면서 사용
// 쓸 데 없이 동일한 기능을 가진 함수를 객체 생성할때마다 생성하지 않는다.
// => 메모리 효율

// 위의 4번 방식은 구조적이지 않다. 개발하기 까다로움 => class를 이용
// 5. class